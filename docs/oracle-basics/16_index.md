---
id: Section 16. Index
sidebar_position: 16
description: Index
---

## Index

```sql
CREATE INDEX index_name
ON table_name(column1[,column2,...])
```

- The index name should be meaningful and includes table alias and column name(s) where possible, along with the suffix \_I such as:

```sql
<table_name>_<column_name>_I
```

- By default, the `CREATE INDEX` statement creates a btree index.
- When you create a new table with a primary key, Oracle automatically creates a new index for the primary key columns.
- Unlike other database systems, Oracle does not automatically create an index for the foreign key columns.

### DROP INDEX IF EXISTS

```sql
DECLARE index_count INTEGER;
BEGIN
SELECT COUNT(*) INTO index_count
    FROM USER_INDEXES
    WHERE INDEX_NAME = 'index_name';

IF index_count > 0 THEN
    EXECUTE IMMEDIATE 'DROP INDEX index_name';
END IF;
END;
/
```

## Unique Index

```sql
CREATE UNIQUE INDEX index_name ON
table_name(column1[,column2,...]);
```

### Specify name for index

- When you define a `PRIMARY KEY` or a `UNIQUE` constraint for a table, Oracle automatically creates a unique index on the primary key or unique key columns to enforce the uniqueness
- SYS_C007876 unique index was created automatically with the generated name.

```sql
CREATE TABLE t2 (
    pk2 INT PRIMARY KEY
        USING INDEX (
            CREATE INDEX t1_pk1_i ON t2 (pk2)
    ),
    c2 INT
);
```

- Instead of generating the index name, Oracle just used the one that we provided during table creation.

## Function based Index

```sql
CREATE INDEX members_last_name_fi
ON members(UPPER(last_name));
```

### A function-based index has the following main advantages:

- A function-based index speeds up the query by giving the optimizer more chance to perform an index range scan instead of full index scan. Note that an index range scan has a fast response time when the `WHERE` clause returns fewer than 15% of the rows of a large table.
- A function-based index reduces computation for the database. If you have a query that consists of expression and use this query many times, the database has to calculate the expression each time you execute the query. To avoid these computations, you can create a function-based index that has the exact expression.
- A function-based index helps you perform more flexible sorts. For example, the index expression can call `UPPER()` and `LOWER()` functions for case-insensitive sorts or `NLSSORT()` function for linguistic-based sorts.

### The following are major disadvantages of function-based indexes:

- The database has to compute the result of the index in every data modification which imposes a performance penalty for every write.
- The function invoked involve in the index expression must be deterministic. It means that for the same input, the function always returns the same result.
- The query optimizer can use a function-based index for cost-based optimization, not for rule-based optimization. Therefore, it does not use a function-based index until you analyze the index itself by invoking either `DBMS_STATS.GATHER_TABLE_STATS` or `DBMS_STATS.GATHER_SCHEMA_STATS`.

## Bitmap Index

- When a column has a few distinct values, we say that this column has low cardinality. Ex: Gender column
- Oracle has a special kind of index for these types of columns which is called a bitmap index.
- A bitmap index is a special kind of database index which uses bitmaps or bit array.
- In a bitmap index, Oracle stores a bitmap for each index key.
- Each index key stores pointers to multiple rows.
- For gender column, It will create two separate bitmaps, one for each gender.
- Oracle uses a mapping function to converts each bit in the bitmap to the corresponding rowid of the table.

```sql
CREATE BITMAP INDEX index_name
ON table_name(column1[,column2,...]);
```

### When to use Oracle bitmap indexes

- You should use the bitmap index for the columns that have low cardinality. To find the cardinality of a column, you can use the following query:

```sql
SELECT column, COUNT(*)
FROM table_name
GROUP BY column;
```

- A good practice is any column which has less than 100 distinct values can consider for bitmap index.
- Maintaining a bitmap index takes a lot of resources, therefore, bitmap indexes are only good for the read-only tables or tables that have infrequently updates.
- Therefore, you often find bitmap indexes are extensively used in the data warehouse environment.
- Notice that using a bitmap index for a table that has many single row update, especially concurrent single row update will cause a deadlock.

Ex:

```sql
CREATE TABLE bitmap_index_demo(
    id INT GENERATED BY DEFAULT AS IDENTITY,
    active NUMBER NOT NULL,
    PRIMARY KEY(id)
);

CREATE BITMAP INDEX bitmap_index_demo_active_i
ON bitmap_index_demo(active);

```

Open two sessions and repeatedly execute one of the following statements in each session:

```sql
INSERT INTO bitmap_index_demo(active)
VALUES(1);

INSERT INTO bitmap_index_demo(active)
VALUES(0);
```

The following error will occur:

```sql
ORA-00060: deadlock detected while waiting for resource
```
