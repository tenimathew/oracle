---
id: Section 10. Data definition
sidebar_position: 10
description: CREATE, ALTER, DROP, TRUNCATE, RENAME, PURGE, COMMENT
---

## CREATE

```sql
CREATE TABLE ot.persons(
    person_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    first_name VARCHAR2(50) NOT NULL,
    last_name VARCHAR2(50) NOT NULL,
    PRIMARY KEY(person_id)
);
```

## ALTER

The ALTER TABLE statement allows you to:

- Add one or more columns
- Modify column definition
- Drop one or more columns
- Rename columns
- Rename table

### ALTER TABLE ADD column examples

```sql
ALTER TABLE persons
ADD birthdate DATE NOT NULL;
```

```sql
ALTER TABLE persons
ADD (
    phone VARCHAR(20),
    email VARCHAR(100)
);
```

Suppose, you want to record the time at which a row is created and updated. To do so, you need to add two columns created_at and updated_at as follows:

```sql
ALTER TABLE
    members ADD(
        created_at TIMESTAMP WITH TIME ZONE NOT NULL,
        updated_at TIMESTAMP WITH TIME ZONE NOT NULL
    );
```

To check whether a column exists in a table, you query the data from the `user_tab_cols` view

For example, the following PL/SQL block checks whether the members table has effective_date column before adding it.

```sql
SET SERVEROUTPUT ON SIZE 1000000
DECLARE
  v_col_exists NUMBER
BEGIN
  SELECT count(*) INTO v_col_exists
    FROM user_tab_cols
    WHERE column_name = 'EFFECTIVE_DATE'
      AND table_name = 'MEMBERS';

   IF (v_col_exists = 0) THEN
      EXECUTE IMMEDIATE 'ALTER TABLE members ADD effective_date DATE';
   ELSE
    DBMS_OUTPUT.PUT_LINE('The column effective_date already exists');
  END IF;
END;
/
```

### ALTER TABLE MODIFY column examples

```sql
ALTER TABLE persons MODIFY birthdate DATE NULL;
```

```sql
ALTER TABLE persons MODIFY(
    phone VARCHAR2(20) NOT NULL,
    email VARCHAR2(255) NOT NULL
);
```

### Modify the column’s visibility

In Oracle Database 12c, you can define table columns as invisible or visible. Invisible columns are not available for the query.

However, you can query the invisible columns by specify them explicitly in the query:

```sql
SELECT invisible_column_1, invisible_column_2
FROM table_name;
```

By default, table columns are visible. You can define invisible column when you create the table or using `ALTER TABLE MODIFY` column statement.

```sql
ALTER TABLE accounts
MODIFY full_name INVISIBLE;
```

```sql
ALTER TABLE accounts
MODIFY full_name VISIBLE;
```

### Modify virtual column

```sql
ALTER TABLE accounts
MODIFY full_name VARCHAR2(52)
GENERATED ALWAYS AS (last_name || ', ' || first_name);
```

### Modify the default value of a column

```sql
ALTER TABLE accounts
ADD status NUMBER( 1, 0 ) DEFAULT 1 NOT NULL ;
```

### ALTER TABLE DROP COLUMN example

```sql
ALTER TABLE persons
DROP COLUMN birthdate;
```

```sql
ALTER TABLE persons
DROP ( email, phone );
```

### ALTER TABLE RENAME column example

```sql
ALTER TABLE persons
RENAME COLUMN first_name TO forename;
```

### ALTER TABLE RENAME table example

```sql
ALTER TABLE persons RENAME TO people;
```

## RENAME

```sql
RENAME table_name TO new_name;
```

When you rename a table, Oracle automatically transfers indexes, constraints, and grants on the old table to the new one. In addition, it invalidates all objects that depend on the renamed table such as views, stored procedures, function, and synonyms.

```sql
RENAME TABLE table_name_1 TO new_table_name_1,
             table_name_2 TO new_table_name_2,
             table_name_3 TO new_table_name_3;
```

## DROP

### Drop Column using SET UNUSED COLUMN clause

The process of dropping a column from a big table can be time and resource consuming. Therefore, we typically drop the column logically by using the A`LTER TABLE SET UNUSED COLUMN` statement as follows:

```sql
ALTER TABLE table_name
SET UNUSED COLUMN column_name;
```

```sql
ALTER TABLE suppliers
SET UNUSED COLUMN fax;
```

Once you execute the statement, the column is no longer visible for accessing.

During the off-peak hours, you can drop the unused columns physically using the following statement:

```sql
ALTER TABLE table_name
DROP UNUSED COLUMNS;
```

If you want to reduce the amount of undo logs accumulated, you can use the `CHECKPOINT` option that forces a checkpoint after the specified number of rows has been processed.

```sql
ALTER TABLE table_name
DROP UNUSED COLUMNS CHECKPOINT 250;
```

You can view the number of unused columns per table from the DBA_UNUSED_COL_TABS view:

```sql
SELECT *
FROM DBA_UNUSED_COL_TABS;
```

### Drop Column using DROP COLUMN clause

```sql
ALTER TABLE table_name
DROP COLUMN column_name;
```

```sql
ALTER TABLE table_name
DROP (
    column_name_1,
    column_name_2
);
```

### DROP TABLE statement

```sql
DROP TABLE schema_name.table_name
[CASCADE CONSTRAINTS | PURGE];
```

In this statement:

- First, indicate the table and its schema that you want to drop after the `DROP TABLE` clause. If you don’t specify the schema name explicitly, the statement assumes that you are removing the table from your own schema.
- Second, specify `CASCADE CONSTRAINTS` clause to remove all referential integrity constraints which refer to primary and unique keys in the table. In case such referential integrity constraints exist and you don’t use this clause, Oracle returns an error and stops removing the table.
- Third, specify `PURGE` clause if you want to drop the table and release the space associated with it at once. By using the `PURGE` clause, Oracle will not place the table and its dependent objects into the recycle bin.
- Notice that the `PURGE` clause does not allow you to roll back or recover the table that you dropped. Therefore, it is useful if you don’t want the sensitive data to appear in the recycle bin.

```sql
DROP TABLE persons;
```

#### DROP TABLE CASCADE CONSTRAINTS example

```sql
CREATE TABLE brands(
    brand_id NUMBER PRIMARY KEY,
    brand_name varchar2(50)
);

CREATE TABLE cars(
    car_id NUMBER PRIMARY KEY,
    make VARCHAR(50) NOT NULL,
    model VARCHAR(50) NOT NULL,
    year NUMBER NOT NULL,
    plate_number VARCHAR(25),
    brand_id NUMBER NOT NULL,

    CONSTRAINT fk_brand
    FOREIGN KEY (brand_id)
    REFERENCES brands(brand_id) ON DELETE CASCADE
);
```

```sql
DROP TABLE brands CASCADE CONSTRAINTS;
```

This statement dropped not only the brands table but also the foreign key constraint fk_brand from the cars table.

#### DROP TABLE PURGE example

```sql
DROP TABLE cars purge;
```

#### Drop multiple tables at once

```sql
CREATE TABLE test_1(c1 VARCHAR2(50));
CREATE TABLE test_2(c1 VARCHAR2(50));
CREATE TABLE test_3(c1 VARCHAR2(50));

BEGIN
  FOR rec IN
    (
      SELECT
        table_name
      FROM
        all_tables
      WHERE
        table_name LIKE 'TEST_%'
    )
  LOOP
    EXECUTE immediate 'DROP TABLE  '||rec.table_name || ' CASCADE CONSTRAINTS';
  END LOOP;
END;
/
```

## VIRTUAL COLUMN

```sql
column_name [data_type] [GENERATED ALWAYS] AS (expression) [VIRTUAL]
```

In this syntax:

- First, specify the name ( column_name) of the virtual column.
- Second, specify the virtual column’s data type. If you omit the data type, the virtual column will take the data type of the result of the expression.
- Third, specify an expression in parentheses after the AS keyword. The values of the virtual column will derive from the expression.
  Note that the `GENERATED ALWAYS` and `VIRTUAL` keywords are for clarity only.

### Creating a table with a virtual column example

```sql
CREATE TABLE table_name (
    ...,
    virtual_column_name AS (expression)
);
```

```sql
CREATE TABLE parts(
    part_id INT GENERATED ALWAYS AS IDENTITY,
    part_name VARCHAR2(50) NOT NULL,
    capacity INT NOT NULL,
    cost DEC(15,2) NOT NULL,
    list_price DEC(15,2) NOT NULL,
    gross_margin AS ((list_price - cost) / cost),
    PRIMARY KEY(part_id)
);

INSERT INTO parts(part_name, capacity, cost, list_price)
VALUES('G.SKILL TridentZ RGB Series 16GB (2 x 8GB)', 16, 95,105);

INSERT INTO parts(part_name, capacity, cost, list_price)
VALUES('G.SKILL TridentZ RGB Series 32GB (4x8GB)', 32, 205,220);

INSERT INTO parts(part_name, capacity, cost, list_price)
VALUES('G.SKILL TridentZ RGB Series 16GB (1 x 8GB)', 8, 50,70);
```

### Adding a virtual column to an existing table example

```sql
ALTER TABLE table_name
ADD (
    virtual_column_name AS (expression)
);
```

```sql
ALTER TABLE parts
ADD (
    capacity_description AS (
            CASE
                WHEN capacity <= 8 THEN 'Small'
                WHEN capacity > 8 AND capacity <= 16 THEN 'Medium'
                WHEN capacity > 16 THEN 'Large'
            END)
)
```

### Advantages and disadvantages of virtual columns

Virtual columns provide the following advantages:

- Virtual columns consume minimal space. Oracle only stores the metadata, not the data of the virtual columns.
- Virtual columns ensure the values are always in sync with the source columns. For example, if you have a date column as the normal column and have the month, quarter, and year columns as the virtual columns. The values in the month, quarter, and year are always in sync with the date column.
- Virtual columns help avoid using views to display derived values from other columns.

The disadvantage of virtual columns is:

- Virtual columns may reduce query performance because their values are calculated at run-time.

### Virtual column limitations

These are limitations of virtual columns:

- Virtual columns are only supported in relational heap tables, but not in index-organized, external, object, cluster, or temporary tables.
- The virtual column cannot be an Oracle-supplied datatype, a user-defined type, or `LOB` or `LONG RAW`.
- The expression in the virtual column has the following restrictions:

The expression in the virtual column has the following restrictions:

- It cannot refer to other virtual columns.
- It cannot refer to normal columns of other tables.
- It must return a scalar value.
- It may refer to a deterministic user-defined function, however, if it does, the virtual column cannot be used as a partitioning key column.

### Show virtual columns of a table

```sql
SELECT
    column_name,
    virtual_column,
    data_default
FROM
    all_tab_cols
WHERE owner = '<owner_name>'
AND table_name = '<table_name>';
```

If the value is the virtual_column is `YES`, it means that the corresponding column is a virtual column. Otherwise, it is a normal column.

## PURGE

Use the `PURGE` statement to remove a table or index from your recycle bin and release all of the space associated with the object.
The following statement removes the table test from the recycle bin. If more than one version of test resides in the recycle bin, Oracle Database removes the version that has been there the longest.

```sql
PURGE TABLE test;
```

To remove the entire contents of your recycle bin, issue the following statement:

```sql
PURGE RECYCLEBIN;
```

To see the contents of your recycle bin

```sql
SELECT * FROM RECYCLEBIN; -- Synonym
SELECT * FROM USER_RECYCLEBIN;
```

## COMMENT

Use the `COMMENT` statement to add a comment about a table, view, materialized view, or column into the data dictionary.

```sql
COMMENT ON COLUMN employees.job_id
   IS 'abbreviated job title';
```

To drop this comment from the database, issue the following statement:

```sql
COMMENT ON COLUMN employees.job_id IS ' ';
```

## Identity column

Oracle 12c introduced a new way that allows you to define an identity column for a table, which is similar to the `AUTO_INCREMENT` column in MySQL or `IDENTITY` column in SQL Server.

```sql
GENERATED [ ALWAYS | BY DEFAULT [ ON NULL ] ]
AS IDENTITY [ ( identity_options ) ]
```

- First, the `GENERATED` keyword is mandatory.

- Second, you can specify an option to generate identity values:
  - `GENERATED ALWAYS`: Oracle always generates a value for the identity column. Attempt to insert a value into the identity column will cause an error.
  - `GENERATED BY DEFAULT`: Oracle generates a value for the identity column if you provide no value. If you provide a value, Oracle will insert that value into the identity column. For this option, Oracle will issue an error if you insert a NULL value into the identity column.
  - `GENERATED BY DEFAULT ON NULL`: Oracle generates a value for the identity column if you provide a NULL value or no value at all.
- Third, you can have a number of options for the identity column.
  - `START WITH` initial_value controls the initial value to use for the identity column. The default initial value is 1.
  - `INCREMENT BY` internval_value defines the interval between generated values. By default, the interval value is 1.
  - `CACHE` defines a number of values that Oracle should generate beforehand to improve the performance. You use this option for the column that has a high number of inserts.

### GENERATED ALWAYS example

```sql
CREATE TABLE identity_demo (
    id NUMBER GENERATED ALWAYS AS IDENTITY,
    description VARCHAR2(100) NOT NULL
);

INSERT INTO identity_demo(description)
VALUES('Oracle identity column demo with GENERATED ALWAYS');
```

The following statement attempts to insert a value into the id identity column:

```sql
INSERT INTO identity_demo(id,description)
VALUES(2,
       'Oracle identity column example with GENERATED ALWAYS ');
```

Oracle issued an error:

```sql
SQL Error: ORA-32795: cannot insert into a generated always identity column
```

Because the id column was defined as `GENERATED ALWAYS`, it could not accept any provided value.

### GENERATED BY DEFAULT example

```sql
DROP TABLE identity_demo;

CREATE  TABLE identity_demo  (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    description VARCHAR2(100) not null
  );

INSERT INTO identity_demo(description)
VALUES('Oracle identity column demo with GENERATED BY DEFAULT');
```

The following statement inserts a new row into the identity_demo table with a provided value for the id column:

```sql
INSERT INTO identity_demo(id,description)
VALUES(2, 'Oracle identity column example with GENERATED BY DEFAULT');
```

The following example attempts to insert a null value into the id column:

```sql
INSERT INTO identity_demo(id,description)
VALUES(NULL,
       'Oracle identity column demo with GENERATED BY DEFAULT, NULL value');
```

Oracle issued an error:

```sql
SQL Error: ORA-01400: cannot insert NULL into ("OT"."IDENTITY_DEMO"."ID")
```

### GENERATED BY DEFAULT ON NULL example

```sql
DROP TABLE identity_demo;

CREATE  TABLE identity_demo  (
    id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    description VARCHAR2(100) not null
  );

INSERT INTO identity_demo(description)
VALUES('Oracle identity column demo with no value');
```

### START WITH option example

```sql
DROP TABLE identity_demo;

CREATE  TABLE identity_demo  (
    id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 100,
    description VARCHAR2(100) not null
  );

INSERT INTO identity_demo(description)
VALUES('Oracle identity column demo with START WITH option');
```

### INCREMENT BY option example

```sql
DROP TABLE identity_demo;

CREATE  TABLE identity_demo (
    id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY START WITH 10 INCREMENT BY 10,
    description VARCHAR2(100) not null
);

INSERT INTO identity_demo(description)
VALUES('Oracle identity column demo 1 with INCREMENT BY option');

INSERT INTO identity_demo(description)
VALUES('Oracle identity column demo 2 with INCREMENT BY option');
```

### Oracle identity column restrictions

- Each table has one and only one identity column.
- The data type of the identity column must be a numeric data type. the user-defined data type is not allowed to use with the identity clause.
- The identity column is not inherited by the `CREATE TABLE` AS `SELECT` statement.
- The identity column cannot have another `DEFAULT` constraint.
- The encryption algorithm for encrypted identity columns can be inferred therefore you should use a strong encryption algorithm.
- The inline constraint of the identity column must not conflict with the `NOT NULL` and `NOT DEFERRABLE` constraint stated by the identity clause.
