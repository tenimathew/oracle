"use strict";(self.webpackChunkoracle=self.webpackChunkoracle||[]).push([[836],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return E}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=c(t),E=r,d=m["".concat(s,".").concat(E)]||m[E]||p[E]||l;return t?a.createElement(d,i(i({ref:n},u),{},{components:t})):a.createElement(d,i({ref:n},u))}));function E(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=t.length,i=new Array(l);i[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=t[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5060:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return s},default:function(){return E},frontMatter:function(){return o},metadata:function(){return c},toc:function(){return p}});var a=t(7462),r=t(3366),l=(t(7294),t(3905)),i=["components"],o={id:"Section 6. Cursors",sidebar_position:6,description:"Cursors"},s=void 0,c={unversionedId:"plsql-tutorial/Section 6. Cursors",id:"plsql-tutorial/Section 6. Cursors",title:"Section 6. Cursors",description:"Cursors",source:"@site/docs/plsql-tutorial/6_cursor.md",sourceDirName:"plsql-tutorial",slug:"/plsql-tutorial/Section 6. Cursors",permalink:"/oracle/plsql-tutorial/Section 6. Cursors",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{id:"Section 6. Cursors",sidebar_position:6,description:"Cursors"},sidebar:"tutorialSidebar",previous:{title:"Section 5. Collections",permalink:"/oracle/plsql-tutorial/Section 5. Collections"},next:{title:"Oracle - Administration",permalink:"/oracle/category/oracle---administration"}},u={},p=[{value:"Implicit cursors",id:"implicit-cursors",level:2},{value:"Explicit cursors",id:"explicit-cursors",level:2},{value:"Parameterized CURSORs",id:"parameterized-cursors",level:3},{value:"Recursive Cursor",id:"recursive-cursor",level:2},{value:"REF CURSOR",id:"ref-cursor",level:2},{value:"Dealing with REF CURSOR in the sub-programs of a PL/SQL block",id:"dealing-with-ref-cursor-in-the-sub-programs-of-a-plsql-block",level:3},{value:"Passing REF CURSOR as parameters to sub-programs",id:"passing-ref-cursor-as-parameters-to-sub-programs",level:3},{value:"Strong REF CURSOR",id:"strong-ref-cursor",level:3},{value:"Strong Ref Cursor with User Defined Record Datatype",id:"strong-ref-cursor-with-user-defined-record-datatype",level:3},{value:"Weak REF CURSOR",id:"weak-ref-cursor",level:3},{value:"SYS_REF CURSOR",id:"sys_ref-cursor",level:3},{value:"CURSOR vs. REF CURSOR",id:"cursor-vs-ref-cursor",level:2},{value:"FOR UPDATE OF, FOR UPDATE and WHERE CURRENT OF",id:"for-update-of-for-update-and-where-current-of",level:2},{value:"INVALID_CURSOR error",id:"invalid_cursor-error",level:2},{value:"PL/SQL Bulk Collect",id:"plsql-bulk-collect",level:2},{value:"Bulk Collect with LIMIT clause",id:"bulk-collect-with-limit-clause",level:3},{value:"FORALL (Bulk Binding)",id:"forall-bulk-binding",level:2},{value:"Lower and Upper bound",id:"lower-and-upper-bound",level:3},{value:"Indices-of bound",id:"indices-of-bound",level:3},{value:"Values-of bound",id:"values-of-bound",level:3},{value:"SQL%BULK_ROWCOUNT",id:"sqlbulk_rowcount",level:3},{value:"SAVE EXCEPTIONS and SQL%BULK_EXCEPTION",id:"save-exceptions-and-sqlbulk_exception",level:3}],m={toc:p};function E(e){var n=e.components,t=(0,r.Z)(e,i);return(0,l.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Cursor is a pointer to a memory area called context area."),(0,l.kt)("li",{parentName:"ul"},"Context area is a memory region inside the Process Global Area(PGA).")),(0,l.kt)("h2",{id:"implicit-cursors"},"Implicit cursors"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Implicit CURSORs are automatically created by Oracle when DML statement such as ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT INTO"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"INSERT"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"UPDATE"),", and ",(0,l.kt)("inlineCode",{parentName:"li"},"DELETE")," is executed. Cursor name is \u2018SQL\u2019."),(0,l.kt)("li",{parentName:"ul"},"Oracle internally manages the whole execution cycle of implicit cursors and reveals only the cursor\u2019s information and statuses such as ",(0,l.kt)("inlineCode",{parentName:"li"},"SQL%ROWCOUNT"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"SQL%ISOPEN"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"SQL%FOUND"),", and ",(0,l.kt)("inlineCode",{parentName:"li"},"SQL%NOTFOUND"),". ",(0,l.kt)("inlineCode",{parentName:"li"},"%ROWCOUNT")),(0,l.kt)("li",{parentName:"ul"},"The implicit cursor is not elegant when the query returns zero or multiple rows which cause ",(0,l.kt)("inlineCode",{parentName:"li"},"NO_DATA_FOUND")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"TOO_MANY_ROWS")," exception respectively.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    total_rows(2);\n    emp_rec emp %ROWTYPE;\nBEGIN\n    SELECT * INTO emp_rec FROM emp WHERE empno=7369;\n    IF SQL %FOUND THEN\n        DBMS_OUTPUT.PUT_LINE(emp_rec.ename ||emp_rec.sal);\n    END IF;\nEND;\n")),(0,l.kt)("h2",{id:"explicit-cursors"},"Explicit cursors"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Explicit CURSORs are user defined cursors. It is created for any DML operation which returns more than 1 row."),(0,l.kt)("li",{parentName:"ul"},"For an explicit cursor, you have control over its execution cycle from ",(0,l.kt)("inlineCode",{parentName:"li"},"OPEN"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"FETCH"),", and ",(0,l.kt)("inlineCode",{parentName:"li"},"CLOSE"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    CURSOR emp_cur IS\n        SELECT empno,ename FROM emp;\n    emp_rec emp_cur %ROWTYPE;\nBEGIN\n    OPEN emp_cur;\n    LOOP\n        FETCH emp_cur INTO emp_rec;\n        EXIT WHEN emp_cur %NOTFOUND;\n        DBMS_OUTPUT.PUT_LINE(emp_rec.empno ||emp_rec.ename);\n    END LOOP;\n    CLOSE emp_cur;\nEND;\n")),(0,l.kt)("h3",{id:"parameterized-cursors"},"Parameterized CURSORs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    emp_rec emp %ROWTYPE;\n    CURSOR emp_cur(max_wage NUMBER :=100, emp_name VARCHAR2) IS --Default value is assigned to parameter max_wage\n        SELECT * FROM emp WHERE sal>max_wage and ename=emp_name;\nBEGIN\n    OPEN emp_cur(2000,'Raj');\n    LOOP\n        FETCH emp_cur INTO emp_rec;\n            EXIT WHEN emp_cur %NOTFOUND;\n            DBMS_OUTPUT.PUT_LINE(emp_rec.ename ||emp_rec.sal);\n        END LOOP;\n    CLOSE emp_cur;\nEND;\n")),(0,l.kt)("h2",{id:"recursive-cursor"},"Recursive Cursor"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A recursive subprogram is one that calls itself. Each recursive call creates a new instance of any items declared in the subprogram, including parameters, variables, cursors, and exceptions. A recursive cursor (a pointer to a shared SQL area) is used to keep a pointer to each call of a recursive function.")),(0,l.kt)("h2",{id:"ref-cursor"},"REF CURSOR"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A ",(0,l.kt)("inlineCode",{parentName:"li"},"REF CURSOR")," is basically a data type."),(0,l.kt)("li",{parentName:"ul"},"A ",(0,l.kt)("inlineCode",{parentName:"li"},"REF CURSOR")," can be associated with more than one ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT")," statement at run-time. Before associating a new ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT")," statement, we need to close the previous ",(0,l.kt)("inlineCode",{parentName:"li"},"CURSOR"),"."),(0,l.kt)("li",{parentName:"ul"},"The primary advantage of using ",(0,l.kt)("inlineCode",{parentName:"li"},"REF CURSOR")," is their capability to pass result sets between sub programs (like stored procedures, functions, packages etc.).")),(0,l.kt)("h3",{id:"dealing-with-ref-cursor-in-the-sub-programs-of-a-plsql-block"},"Dealing with REF CURSOR in the sub-programs of a PL/SQL block"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The sub-routine gets executed for every iteration, which displays the employee information for the respective department.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE r_cursor IS REF CURSOR;\n    c_emp r_cursor;\n    TYPE rec_emp IS RECORD(\n        name VARCHAR2(20),\n        sal NUMBER(6));\n    er rec_emp;\n\n    PROCEDURE printemployeedetails IS\n    BEGIN\n        LOOP\n            FETCH c_emp INTO ER;\n            EXIT WHEN c_emp %NOTFOUND;\n            DBMS_OUTPUT.PUT_LINE(er.name || ' \u2013' || er.sal);\n        END LOOP;\n    END;\n\n    BEGIN\n        FOR i IN (SELECT deptno,dname FROM dept) --can use SELECT statement directly without defining a cursor\n        LOOP\n            OPEN c_emp FOR SELECT ename,sal FROM emp WHERE deptno = i.deptno;\n                DBMS_OUTPUT.PUT_LINE(i.dname);\n                DBMS_OUTPUT.PUT_LINE('\u2014\u2014\u2014\u2014\u2013');\n                printemployeedetails;\n            CLOSE c_emp;\n        END LOOP;\nEND;\n")),(0,l.kt)("h3",{id:"passing-ref-cursor-as-parameters-to-sub-programs"},"Passing REF CURSOR as parameters to sub-programs"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE r_cursor IS REF CURSOR;\n    c_emp r_cursor;\n    TYPE rec_emp IS RECORD(\n        NAME VARCHAR2(20),\n        sal NUMBER(6));\n\n    PROCEDURE printemployeedetails(p_emp r_cursor) IS\n        er rec_emp;\n    BEGIN\n        LOOP\n            FETCH p_emp INTO er; --no need to OPEN\n            EXIT WHEN p_emp %NOTFOUND;\n            DBMS_OUTPUT.PUT_LINE(er.name || ' \u2013' || er.sal);\n        END LOOP;\n    END;\n\n    BEGIN\n        FOR i IN (SELECT deptno,dname FROM dept)\n        LOOP\n            OPEN c_emp FOR SELECT ename,sal FROM EMP WHERE deptno = i.deptno;\n                DBMS_OUTPUT.PUT_LINE(i.dname);\n                DBMS_OUTPUT.PUT_LINE('\u2014\u2014\u2014\u2014\u2013');\n                printemployeedetails(c_emp);\n            CLOSE c_emp;\n        END LOOP;\nEND;\n")),(0,l.kt)("h3",{id:"strong-ref-cursor"},"Strong REF CURSOR"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Any ",(0,l.kt)("inlineCode",{parentName:"li"},"REF CURSOR")," which has fixed return type is called Strong ",(0,l.kt)("inlineCode",{parentName:"li"},"REF CURSOR")),(0,l.kt)("li",{parentName:"ul"},"Strong ",(0,l.kt)("inlineCode",{parentName:"li"},"REF CURSOR")," supports different type of ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT")," statements but all of the same structure ,but not necessary that the table should be same.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE ref_cursor_name IS REF CURSOR\n        RETURN (return_type);--Return must be of RECORD datatype\n----\nDECLARE\n    TYPE my_RefCur IS REF CURSOR\n        RETURN employees %ROWTYPE;\n    cur_var my_RefCur;\n    rec_var employees %ROWTYPE;\nBEGIN\n    OPEN cur_var FOR SELECT * FROM employees WHERE employee_id =100;\n        FETCH cur_var INTO rec_var;\n    CLOSE cur_var;\n    DBMS_OUTPUT.PUT_LINE(rec_var.first_name || rec_var.salary);\nEND;\n")),(0,l.kt)("h3",{id:"strong-ref-cursor-with-user-defined-record-datatype"},"Strong Ref Cursor with User Defined Record Datatype"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Use of this is, we can customize the number of field we want to fetch and still we can have a record datatype for Strong Ref Cursor")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE my_rec IS RECORD(\n        emp_sal employees.salary %TYPE;);\n    TYPE my_RefCur IS REF CURSOR\n        RETURN my_rec;--User defined RECORD datatype for return\n    cur_var my_RefCur;\n    at_var employees.salary %TYPE;\nBEGIN\n    OPEN cur_var FOR SELECT salary FROM employees WHERE employee_id =100;\n        FETCH cur_var INTO at_var;\n    CLOSE cur_var;\n    DBMS_OUTPUT.PUT_LINE('Salary:' || at_var);\nEND;\n")),(0,l.kt)("h3",{id:"weak-ref-cursor"},"Weak REF CURSOR"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Weak REF CURSORs are those cursors which do not have any return type"),(0,l.kt)("li",{parentName:"ul"},"These cursors are the most frequently used ",(0,l.kt)("inlineCode",{parentName:"li"},"REF CURSOR")," as they are open to all ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT")," statements"),(0,l.kt)("li",{parentName:"ul"},"This ",(0,l.kt)("inlineCode",{parentName:"li"},"REF CURSOR")," allows us to fetch any type of ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT")," statement irrespective of data structure .")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE ref_cursor_name IS REF CURSOR;\n----\nDECLARE\n    TYPE my_RefCur IS REF CURSOR;\n    cur_var my_RefCur;\n    f_name employees.first_name %TYPE;\n    emp_sal employees.salary %TYPE;\nBEGIN\n    OPEN cur_var FOR SELECT first_name, salary FROM employees WHERE employee_id =100;\n        FETCH cur_var INTO f_name,emp_sal;\n    CLOSE cur_var;\n    DBMS_OUTPUT.PUT_LINE(f_name || emp_sal);\nEND;\n")),(0,l.kt)("h3",{id:"sys_ref-cursor"},"SYS_REF CURSOR"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It is a predefined weak ",(0,l.kt)("inlineCode",{parentName:"li"},"REF CURSOR")," (",(0,l.kt)("inlineCode",{parentName:"li"},"TYPE SYS_REFCURSOR IS REF CURSOR"),");. So without declaring the ref pointer type, you can assign variable.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    cur_var SYS_REFCURSOR;\n    f_name employees.first_name %TYPE;\n    emp_sal employees.salary %TYPE;\nBEGIN\n    OPEN cur_var FOR SELECT first_name, salary FROM employees WHERE employee_id =100;\n        FETCH cur_var INTO f_name,emp_sal;\n    CLOSE cur_var;\n    DBMS_OUTPUT.PUT_LINE(f_name || emp_sal);\nEND;\n")),(0,l.kt)("h2",{id:"cursor-vs-ref-cursor"},"CURSOR vs. REF CURSOR"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"REF CURSOR"),(0,l.kt)("th",{parentName:"tr",align:null},"CURSOR"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Dynamic"),(0,l.kt)("td",{parentName:"tr",align:null},"Static")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Can be associated with multiple SELECT statements in a PL/SQL block"),(0,l.kt)("td",{parentName:"tr",align:null},"Can only access single SELECT statement at a time")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Can be changed at run time"),(0,l.kt)("td",{parentName:"tr",align:null},"Cannot be changed at run time. Can be done with parameterized cursor.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Can be returned to the client application"),(0,l.kt)("td",{parentName:"tr",align:null},"Cannot be returned to the client application")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Cannot be global. Cannot define them OUTSIDE of a procedure / function"),(0,l.kt)("td",{parentName:"tr",align:null},"Can be global. Global cursors can be opened and executed outside of the package in which they are defined")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Can be passed from one sub-program to other sub-program"),(0,l.kt)("td",{parentName:"tr",align:null},"Cannot be passed")))),(0,l.kt)("h2",{id:"for-update-of-for-update-and-where-current-of"},"FOR UPDATE OF, FOR UPDATE and WHERE CURRENT OF"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"FOR UPDATE")," will give exclusive row-level lock on all rows retrieved by ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT")," statement."),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"FOR UPDATE")," clause is generally used in cases where an online system needs to display a set of row data on a screen and they need to ensure that the data does not change before the end-user has an opportunity to update the data. In the real-world, many large online systems do not use the ",(0,l.kt)("inlineCode",{parentName:"li"},"FOR UPDATE")," clause."),(0,l.kt)("li",{parentName:"ul"},"If you try to access the rows with the ",(0,l.kt)("inlineCode",{parentName:"li"},"NOWAIT")," clause, you will get an error message, ",(0,l.kt)("inlineCode",{parentName:"li"},"ORA-00054 Resource busy and acquire with NOWAIT")," specified. ",(0,l.kt)("inlineCode",{parentName:"li"},"NOWAIT")," option is just to investigate that yes i am not at all willing to wait to acquire the lock rather than hang myself, If i cannot get the lock immediately, an error is returned to signal that the lock is not possible at this time. You may try again later."),(0,l.kt)("li",{parentName:"ul"},"If there are more than one table are joined for update, then the use of ",(0,l.kt)("inlineCode",{parentName:"li"},"FOR UPDATE OF"),"... will only lock the rows in the tables that contain the columns you specify in the OF clause. You can never lock a single column, the minimum lock is at row level. It locks all rows in the table that contains the column, which are selected by the query."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"WHERE CURRENT OF")," clause can be used for both ",(0,l.kt)("inlineCode",{parentName:"li"},"DELETE")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"UPDATE")," statements inside a cursor's range to make changes to the last fetched row(s)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CURSOR cursor_name IS\n    SELECT * FROM ..\n    FOR UPDATE [OF column_list] [WAIT 15] [NOWAIT];\n--NOWAIT -cursor does not wait for resources. If it is locked, it will show error\n--WAIT 15 -wait up to 15 seconds for another session to release their lock. If not, show error\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    CURSOR cur IS\n        SELECT * FROM departments WHERE department_id = 210 FOR UPDATE;\n    emp_rec departments %ROWTYPE;\nBEGIN\n    OPEN cur;\n        LOOP\n            FETCH cur INTO emp_rec;\n            EXIT WHEN cur %NOTFOUND;\n            INSERT INTO emp_log VALUES emp_rec;\n            DELETE FROM departments WHERE CURRENT OF cur;\n        END LOOP;\n        COMMIT;\n    CLOSE cur;\nEND;\n")),(0,l.kt)("h2",{id:"invalid_cursor-error"},"INVALID_CURSOR error"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If the cursor is not opened it will show INVALID_CURSOR")),(0,l.kt)("h2",{id:"plsql-bulk-collect"},"PL/SQL Bulk Collect"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Bulk collect is used to reduce the context switching between SQL engine and PL/SQL engine and to improve query performance."),(0,l.kt)("li",{parentName:"ul"},"Bulk collect will reduce the context switching by collecting all the SQL statement calls from PL/SQL program and sending them to SQL engine in just one go and vice versa."),(0,l.kt)("li",{parentName:"ul"},"Bulk collect clause can be used with ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT INTO"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"FETCH INTO"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"RETURNING INTO")," statements.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE rc_emp IS RECORD(\n        v_empno employees.employee_id%TYPE,\n        v_ename employees.first_name%TYPE,\n        v_sal employees.salary%TYPE);\n    TYPE cl_emp IS TABLE OF rc_emp;\n    v_emp cl_emp;\nBEGIN\n    SELECT employee_id, first_name, salary\n        BULK COLLECT INTO v_emp FROM employees;\n    FOR i IN 1..v_emp.COUNT LOOP\n        DBMS_OUTPUT.PUT_LINE(v_emp(i).v_empno || v_emp(i).v_ename || v_emp(i).v_sal);\n    END LOOP;\n\n    FORALL i IN 1..v_emp.COUNT\n        INSERT INTO temp_emp (employee_id,first_name,salary)\n            VALUES(v_emp(i).v_empno, v_emp(i).v_ename, v_emp(i).v_sal);\nEND;\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE nt_fName IS TABLE OF VARCHAR2(20);\n    fname nt_fName;\nBEGIN\n    SELECT first_name BULK COLLECT INTO fname FROM employees; --variable should be a collection\n    FOR i IN 1..fname.COUNT LOOP\n        DBMS_OUTPUT.PUT_LINE(i||fname(i));\n    END LOOP;\nEND;\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    CURSOR exp_cur IS\n    SELECT first_name FROM employees;\n    TYPE nt_fNAME IS TABLE OF VARCHAR2(20);\n    fname nt_fNAME;\nBEGIN\n    OPEN exp_cur;\n        FETCH exp_cur BULK COLLECT INTO fname;--Bulk collect does not need loop\n    FOR i IN fname.FIRST..fname.LAST LOOP\n        DBMS_OUTPUT.PUT_LINE(i||fname(i));\n    END LOOP;\n    CLOSE exp_cur;\nEND;\n")),(0,l.kt)("h3",{id:"bulk-collect-with-limit-clause"},"Bulk Collect with LIMIT clause"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Whenever we retrieve a large number of records using bulk collect, the program starts consuming lot of memory in order to be fast and efficient. That degrades the performance of the database."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"LIMIT")," clause will restrict the number of rows fetched."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"LIMIT")," clause can be only used with ",(0,l.kt)("inlineCode",{parentName:"li"},"FETCH INTO")," statement.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    CURSOR exp_cur IS\n        SELECT first_name FROM employees;\n    TYPE nt_fNAME IS TABLE OF VARCHAR2(20);\n    fname nt_fNAME;\nBEGIN\n    OPEN exp_cur;\n    LOOP\n        FETCH exp_cur BULK COLLECT INTO fname LIMIT 10;\n        FOR i IN 1..fname.COUNT LOOP\n            DBMS_OUTPUT.PUT_LINE(i||fname(i));\n        END LOOP;\n        EXIT WHEN fname.COUNT = 0;\n    END LOOP;\n    CLOSE exp_cur;\nEND;\n")),(0,l.kt)("h2",{id:"forall-bulk-binding"},"FORALL (Bulk Binding)"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"FORALL")," statement reduces context switches which occur during the execution of a DML statement by sending it in batches instead of one at a time."),(0,l.kt)("li",{parentName:"ul"},"With ",(0,l.kt)("inlineCode",{parentName:"li"},"BULK COLLECT")," we were fetching data from table and storing it into the collection. But in ",(0,l.kt)("inlineCode",{parentName:"li"},"FORALL")," statement, we will fetch the data from the collection and store it into the table."),(0,l.kt)("li",{parentName:"ul"},"A ",(0,l.kt)("inlineCode",{parentName:"li"},"FORALL")," statement can have only one DML statement at a time.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"FORALL i IN bound_clause --Bound clause decides the number of iteration.\n[SAVE EXCEPTIONS] --It helps the DML statements to keep running even when there is an exception. --Using this is recommended\n--DML statement;\n")),(0,l.kt)("h3",{id:"lower-and-upper-bound"},"Lower and Upper bound"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The collection should have consecutive index numbers."),(0,l.kt)("li",{parentName:"ul"},"If an element in the range is missing or was deleted, PL/SQL raises an exception.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE myArray IS TABLE OF NUMBER(2);\n    col_var myArray := myArray(9,45,1,24,5,4,7,54,6,23);\nBEGIN\n    FORALL i IN 1..col_var.COUNT\n        INSERT INTO tbl_mulpxn VALUES (col_var(i));\n    DBMS_OUTPUT.PUT_LINE(SQL %ROWCOUNT);\nEND;\n")),(0,l.kt)("h3",{id:"indices-of-bound"},"Indices-of bound"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The indexes need not be consecutive."),(0,l.kt)("li",{parentName:"ul"},"If a subscript in the range does not exist in the collection, that subscript is skipped."),(0,l.kt)("li",{parentName:"ul"},"If collection is an associative array, it must be indexed by ",(0,l.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE myArray IS TABLE OF NUMBER(2);\n    col_var myArray := myArray(9,45,1,24,5,4,7,54,6,23);\nBEGIN\n    col_var.DELETE(3 , 6);\n    FORALL i IN INDICES OF col_var\n        INSERT INTO tbl_mulpxn VALUES (col_var(i));\n    DBMS_OUTPUT.PUT_LINE(SQL %ROWCOUNT);\nEND;\n----\nDECLARE\n    TYPE myArray IS TABLE OF NUMBER(2);\n    col_var myArray := myArray(9,45,1,24,5,4,7,54,6,23);\nBEGIN\n    col_var.DELETE(3 , 6);\n    FORALL i IN INDICES OF col_var BETWEEN 1 AND 10\n        INSERT INTO tbl_mulpxn VALUES (col_var(i));\n    DBMS_OUTPUT.PUT_LINE(SQL %ROWCOUNT);\nEND;\n")),(0,l.kt)("h3",{id:"values-of-bound"},"Values-of bound"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It requires two collection; source collection and indexing collection"),(0,l.kt)("li",{parentName:"ul"},"The subscripts for the ",(0,l.kt)("inlineCode",{parentName:"li"},"FORALL")," indexing collection are taken from the values of the elements in source collection"),(0,l.kt)("li",{parentName:"ul"},"The indexing collection must be a nested table, or an associative array"),(0,l.kt)("li",{parentName:"ul"},"The elements of the indexing collection must be of either ",(0,l.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"BINARY_INTEGER")),(0,l.kt)("li",{parentName:"ul"},"If it is associate array, then it must be indexed by ",(0,l.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"BINARY_INTEGER")),(0,l.kt)("li",{parentName:"ul"},"Indexing collection is a group of indexes that the ",(0,l.kt)("inlineCode",{parentName:"li"},"FORALL")," statement can loop through")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE myArray IS TABLE OF NUMBER(2);--Source collection\n    src_col myArray := myArray(9,45,1,24,5,4,7,54,6,23);\n    TYPE yourArray IS TABLE OF PLS_INTEGER;--Indexing collection\n    idx_col yourArray:=yourArray();\nBEGIN\n    idx_col.EXTEND(2);\n    idx_col(1):=4; --24 inserted here; src_col(4)\n    idx_col(2):=8; --54 inserted here; src_col(8)\n    FORALL i IN VALUES OF idx_col --idx_col(1) = 4; i =4\n        INSERT INTO tbl_mulpxn VALUES (src_col(i)); --src_col(4) = 24\n    DBMS_OUTPUT.PUT_LINE(SQL %ROWCOUNT);\nEND;\n")),(0,l.kt)("h3",{id:"sqlbulk_rowcount"},"SQL%BULK_ROWCOUNT"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"SQL%BULK_ROWCOUNT")," cursor attribute gives granular information about the rows affected by each iteration of the FORALL statement."),(0,l.kt)("li",{parentName:"ul"},"Every row in the driving collection has a corresponding row in the ",(0,l.kt)("inlineCode",{parentName:"li"},"SQL%BULK_ROWCOUNT")," cursor attribute."),(0,l.kt)("li",{parentName:"ul"},'In the below code, we can see that rows affected for the username "BANANA" is zero.')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE bulk_rowcount_test AS\n    SELECT *\n    FROM all_users;\n----\nDECLARE\n    TYPE t_array_tab IS TABLE OF VARCHAR2(30);\n    l_array t_array_tab := t_array_tab('SCOTT', 'SYS','SYSTEM', 'DBSNMP', 'BANANA');\nBEGIN\n    --Perform bulk delete operation.\n    FORALL i IN l_array.FIRST .. l_array.LAST\n        DELETE FROM bulk_rowcount_test\n            WHERE username = l_array(i);\n    --Report affected rows.\n    FOR i IN l_array.FIRST .. l_array.LAST LOOP\n        DBMS_OUTPUT.PUT_LINE('Element: ' || RPAD(l_array(i), 15, ' ') ||\n        ' Rows affected: ' || SQL %BULK_ROWCOUNT(i));\n    END LOOP;\nEND;\n/\nElement: SCOTT Rows affected: 1\nElement: SYS Rows affected: 1\nElement: SYSTEM Rows affected: 1\nElement: DBSNMP Rows affected: 1\nElement: BANANA Rows affected: 0\n")),(0,l.kt)("h3",{id:"save-exceptions-and-sqlbulk_exception"},"SAVE EXCEPTIONS and SQL%BULK_EXCEPTION"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The following code creates a collection with 100 rows, but sets the value of rows 50 and 51 to NULL."),(0,l.kt)("li",{parentName:"ul"},'Since the "exception_test" table does not allow nulls, these rows will result in an exception.'),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"SAVE EXCEPTIONS")," clause allows the bulk operation to continue past any exceptions, but if any exceptions were raised , it will jump to the exception handler once all the operations are complete."),(0,l.kt)("li",{parentName:"ul"},"In this case, the exception handler just loops through the ",(0,l.kt)("inlineCode",{parentName:"li"},"SQL%BULK_EXCEPTION")," cursor attribute to see what errors occurred.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE exception_test (\n    id NUMBER(10) NOT NULL);\n----\nDECLARE\n    TYPE t_tab IS TABLE OF exception_test%ROWTYPE;\n    l_tab t_tab := t_tab();\n    l_error_count NUMBER(10);\n    ex_dml_errors EXCEPTION;\n    PRAGMA EXCEPTION_INIT(ex_dml_errors, -24381);\nBEGIN\n    --Fill the collection.\n    FOR i IN 1..100 LOOP\n        l_tab.EXTEND;\n        l_tab(i).id := i;\n    END LOOP;\n\n    --Cause a failure.\n    l_tab(50).id := NULL;\n    l_tab(51).id := NULL;\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE exception_test';\n\n    --Perform a bulk operation.\n    BEGIN\n        FORALL i IN l_tab.FIRST..l_tab.LAST SAVE EXCEPTIONS\n            INSERT INTO exception_test\n                VALUES l_tab(i);\n    EXCEPTION\n        WHEN ex_dml_errors THEN\n            l_error_count := SQL%BULK_EXCEPTIONS.COUNT;\n            DBMS_OUTPUT.PUT_LINE('Number of failures: ' || l_error_count);\n            FOR i IN 1 .. l_error_count LOOP\n                DBMS_OUTPUT.PUT_LINE('Error: ' || i ||\n                ' Array Index: ' || SQL%BULK_EXCEPTIONS(i).ERROR_INDEX ||\n                ' Error Code: ' || SQL%BULK_EXCEPTIONS(i).ERROR_CODE ||\n                ' Message1: ' || SQLERRM(SQL%BULK_EXCEPTIONS(i).ERROR_CODE) ||\n                ' Message2: ' || SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE)) ;\n            END LOOP;\n    END;\nEND;\n/\nNumber of failures: 2\nError: 1 Array Index: 50 Error Code: 1400 Message1: -1400: non-ORACLE exception Message2: ORA-01400: cannot insert NULL into ()\nError: 2 Array Index: 51 Error Code: 1400 Message1: -1400: non-ORACLE exception Message2: ORA-01400: cannot insert NULL into ()\n")))}E.isMDXComponent=!0}}]);