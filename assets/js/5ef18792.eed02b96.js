"use strict";(self.webpackChunkoracle=self.webpackChunkoracle||[]).push([[9169],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return E}});var n=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,l=function(e,t){if(null==e)return{};var a,n,l={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=d(a),E=l,c=u["".concat(s,".").concat(E)]||u[E]||m[E]||i;return a?n.createElement(c,r(r({ref:t},p),{},{components:a})):n.createElement(c,r({ref:t},p))}));function E(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=a.length,r=new Array(i);r[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,r[1]=o;for(var d=2;d<i;d++)r[d]=a[d];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},4987:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return E},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return m}});var n=a(7462),l=a(3366),i=(a(7294),a(3905)),r=["components"],o={id:"Section 1. PLSQL",sidebar_position:1,description:"PLSQL"},s=void 0,d={unversionedId:"plsql-tutorial/Section 1. PLSQL",id:"plsql-tutorial/Section 1. PLSQL",title:"Section 1. PLSQL",description:"PLSQL",source:"@site/docs/plsql-tutorial/plsql.md",sourceDirName:"plsql-tutorial",slug:"/plsql-tutorial/Section 1. PLSQL",permalink:"/oracle/plsql-tutorial/Section 1. PLSQL",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"Section 1. PLSQL",sidebar_position:1,description:"PLSQL"},sidebar:"tutorialSidebar",previous:{title:"PL/SQL Tutorial",permalink:"/oracle/category/plsql-tutorial"},next:{title:"Section 2. Conditional control",permalink:"/oracle/plsql-tutorial/Section 2. Conditional control"}},p={},m=[{value:"What is PL/SQL?",id:"what-is-plsql",level:2},{value:"Advantages of PLSQL",id:"advantages-of-plsql",level:2},{value:"PL/SQL Blocks",id:"plsql-blocks",level:2},{value:"Anonymous Block",id:"anonymous-block",level:3},{value:"Named Block",id:"named-block",level:3},{value:"Early vs. Late Binding",id:"early-vs-late-binding",level:2},{value:"PL/SQL data types",id:"plsql-data-types",level:2},{value:"Numeric data types",id:"numeric-data-types",level:3},{value:"Boolean data type",id:"boolean-data-type",level:3},{value:"Character data types",id:"character-data-types",level:3},{value:"Datetime data types",id:"datetime-data-types",level:3},{value:"Data type synonyms",id:"data-type-synonyms",level:3},{value:"RAW Datatype",id:"raw-datatype",level:3},{value:"CONSTANT, DEFAULT, NOT NULL",id:"constant-default-not-null",level:3},{value:"Host/Bind/Session Variable",id:"hostbindsession-variable",level:2},{value:"Anchored Data type/ Inheriting data type",id:"anchored-data-type-inheriting-data-type",level:2},{value:"Execute Immediate",id:"execute-immediate",level:2},{value:"Single Row Queries",id:"single-row-queries",level:3},{value:"DDL Operations",id:"ddl-operations",level:3},{value:"PL/SQL Block using EXECUTE IMMEDIATE",id:"plsql-block-using-execute-immediate",level:3},{value:"Bind Variable",id:"bind-variable",level:3},{value:"BULK COLLECT INTO with EXECUTE IMMEDIATE",id:"bulk-collect-into-with-execute-immediate",level:3},{value:"UTL_MAIL",id:"utl_mail",level:2},{value:"UTL_FILE",id:"utl_file",level:2},{value:"External tables",id:"external-tables",level:2},{value:"Import data from Excel to Oracle using SQL Developer",id:"import-data-from-excel-to-oracle-using-sql-developer",level:2},{value:"XMLELEMENT",id:"xmlelement",level:2},{value:"SQL Loader",id:"sql-loader",level:2},{value:"Local Screening",id:"local-screening",level:2}],u={toc:m};function E(e){var t=e.components,a=(0,l.Z)(e,r);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"what-is-plsql"},"What is PL/SQL?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Procedural Language/ Standard Query Language."),(0,i.kt)("li",{parentName:"ul"},"It is a procedural server side programming language"),(0,i.kt)("li",{parentName:"ul"},"Used to bridge the gap of SQL being non-procedural."),(0,i.kt)("li",{parentName:"ul"},"Case-insensitive programming language.")),(0,i.kt)("h2",{id:"advantages-of-plsql"},"Advantages of PL\\SQL"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Tight integration with SQL"),(0,i.kt)("li",{parentName:"ul"},"Business logic can be directly implemented at database level"),(0,i.kt)("li",{parentName:"ul"},"High performance, High productivity"),(0,i.kt)("li",{parentName:"ul"},"Support object oriented programming")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n--Declaration statements\nBEGIN\n--Executable statements\nEXCEPTION\n--Exception handling statements\nEND;\n")),(0,i.kt)("h2",{id:"plsql-blocks"},"PL/SQL Blocks"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Blocks are basic programming units in PL/SQL programming language")),(0,i.kt)("h3",{id:"anonymous-block"},"Anonymous Block"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"As this block is created without a name, this block does not create any object in the database. Thus, the scope for reusability is zero. It compiles every time you execute.")),(0,i.kt)("h3",{id:"named-block"},"Named Block"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It creates a database object. Complied for one time and stored for reuse.")),(0,i.kt)("h2",{id:"early-vs-late-binding"},"Early vs. Late Binding"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Late binding means code is compiled at execution. Early binding means code is compiled prior to execution.")),(0,i.kt)("h2",{id:"plsql-data-types"},"PL/SQL data types"),(0,i.kt)("p",null,"PL/SQL divides the scalar data types into four families:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Number"),(0,i.kt)("li",{parentName:"ul"},"Boolean"),(0,i.kt)("li",{parentName:"ul"},"Character"),(0,i.kt)("li",{parentName:"ul"},"Datetime")),(0,i.kt)("p",null,"A scalar data type may have subtypes. A subtype is a data type that is a subset of another data type, which is its base type. A subtype further defines a base type by restricting the value or size of the base data type."),(0,i.kt)("p",null,"Note that PL/SQL scalar data types include SQL data types and its own data type such as Boolean."),(0,i.kt)("h3",{id:"numeric-data-types"},"Numeric data types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The numeric data types represent real numbers, integers, and floating-point numbers. They are stored as ",(0,i.kt)("inlineCode",{parentName:"li"},"NUMBER"),", IEEE floating-point storage types (",(0,i.kt)("inlineCode",{parentName:"li"},"BINARY_FLOAT")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"BINARY_DOUBLE"),"), and PLS_INTEGER."),(0,i.kt)("li",{parentName:"ul"},"The data types ",(0,i.kt)("inlineCode",{parentName:"li"},"NUMBER"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"BINARY_FLOAT"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"BINARY_DOUBLE")," are SQL data types."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," datatype is specific to PL/SQL. It represents signed 32 bits integers that range from -2,147,483,648 to 2,147,483,647."),(0,i.kt)("li",{parentName:"ul"},"Because ",(0,i.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," datatype uses hardware arithmetic, they are faster than ",(0,i.kt)("inlineCode",{parentName:"li"},"NUMBER")," operations, which uses software arithmetic."),(0,i.kt)("li",{parentName:"ul"},"In addition, ",(0,i.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," values require less storage than ",(0,i.kt)("inlineCode",{parentName:"li"},"NUMBER"),". Hence, you should always use ",(0,i.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," values for all calculation in its range to increase the efficiency of programs."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"BINARY_INTEGER")," data types are identical.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"PLS_INTEGER")," datatype has the following predefined subtypes:\n| PLS_INTEGER subtypes | Description |\n|----------------------|---------------------------------------------------------------------------------------|\n| NATURAL | Represents nonnegative PLS_INTEGER values |\n| NATURALN | Represents nonnegative PLS_INTEGER values with NOT NULL constraint |\n| POSITIVE | Represents positive PLS_INTEGER values |\n| POSITIVEN | Represents positive PLS_INTEGER value with NOT NULL constraint |\n| SIGNTYPE | Represents three values -1, 0, or 1, which are useful for tri-state logic programming |\n| SIMPLE_INTEGER | Represents PLS_INTEGER values with NOT NULL constraint. |"),(0,i.kt)("h3",{id:"boolean-data-type"},"Boolean data type"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"BOOLEAN")," datatype has three data values: ",(0,i.kt)("inlineCode",{parentName:"p"},"TRUE"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FALSE"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"NULL"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Boolean values are typically used in control flow structure such as ",(0,i.kt)("inlineCode",{parentName:"p"},"IF-THEN"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"CASE"),", and loop statements like ",(0,i.kt)("inlineCode",{parentName:"p"},"LOOP"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FOR LOOP"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"WHILE LOOP"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"SQL does not have the ",(0,i.kt)("inlineCode",{parentName:"p"},"BOOLEAN")," data type, therefore, you cannot:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Assign a ",(0,i.kt)("inlineCode",{parentName:"li"},"BOOLEAN")," value to a table column."),(0,i.kt)("li",{parentName:"ul"},"Select the value from a table column into a ",(0,i.kt)("inlineCode",{parentName:"li"},"BOOLEAN")," variable."),(0,i.kt)("li",{parentName:"ul"},"Use a ",(0,i.kt)("inlineCode",{parentName:"li"},"BOOLEAN")," value in a SQL function."),(0,i.kt)("li",{parentName:"ul"},"Use a ",(0,i.kt)("inlineCode",{parentName:"li"},"BOOLEAN")," expression in a SQL statement."),(0,i.kt)("li",{parentName:"ul"},"Use a ",(0,i.kt)("inlineCode",{parentName:"li"},"BOOLEAN")," value in the ",(0,i.kt)("inlineCode",{parentName:"li"},"DBMS_OUTPUT.PUTLINE")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"DBMS_OUTPUT.PUT")," subprograms.")))),(0,i.kt)("h3",{id:"character-data-types"},"Character data types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The character data types represent alphanumeric text. PL/SQL uses the SQL character data types such as ",(0,i.kt)("inlineCode",{parentName:"li"},"CHAR"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"VARCHAR2"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"LONG"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"RAW"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"LONG RAW"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ROWID"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"UROWID"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CHAR(n)")," is a fixed-length character type whose length is from 1 to 32,767 bytes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"VARCHAR2(n)")," is varying length character data from 1 to 32,767 bytes.")),(0,i.kt)("h3",{id:"datetime-data-types"},"Datetime data types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The datetime data types represent dates, timestamp with or without time zone and intervals."),(0,i.kt)("li",{parentName:"ul"},"PL/SQL datetime data types are ",(0,i.kt)("inlineCode",{parentName:"li"},"DATE"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"TIMESTAMP"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"TIMESTAMP WITH TIME ZONE"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"TIMESTAMP WITH LOCAL TIME ZONE"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"INTERVAL YEAR TO MONTH"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"INTERVAL DAY TO SECOND"),".")),(0,i.kt)("h3",{id:"data-type-synonyms"},"Data type synonyms"),(0,i.kt)("p",null,"Data types have synonyms for compartibility with non-Oracle data sources such as IBM Db2, SQL Server. And it is not a good practice to use data type synonym unless you are accessing a non-Oracle Database.\n| Data Type | Synonyms |\n|-----------|------------------------------------------------------------------------------|\n| NUMBER | DEC, DECIMAL, DOUBLE PRECISION, FLOAT, INTEGER, INT, NUMERIC, REAL, SMALLINT |\n| CHAR | CHARACTER, STRING |\n| VARCHAR2 | VARCHAR |"),(0,i.kt)("h3",{id:"raw-datatype"},"RAW Datatype"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In Oracle PL/SQL, RAW is a data type used to store binary data, or data which is byte oriented (for example, graphics or audio files). One of the most important things to note about RAW data is that it can only be queried or inserted; RAW data cannot be manipulated. RAW data is always returned as a hexadecimal character value")),(0,i.kt)("h3",{id:"constant-default-not-null"},"CONSTANT, DEFAULT, NOT NULL"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"SET SERVEROUTPUT ON;\n\nDECLARE\n    V_PI CONSTANT NUMBER(7,6):=3.14; --Assigning is mandatory\n    V_NAME VARCHAR2(20) DEFAULT 'Unknown'; --Assigning is mandatory\n    V_AGE NUMBER NOT NULL :=50; --Assigning is mandatory\nBEGIN\n    DBMS_OUTPUT.PUT_LINE('v_pi:' ||V_PI);\n    DBMS_OUTPUT.PUT_LINE('v_name:'||V_NAME);\n    DBMS_OUTPUT.PUT_LINE('v_age:'||V_AGE);\nEND;\n")),(0,i.kt)("h2",{id:"hostbindsession-variable"},"Host/Bind/Session Variable"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It is a variable of the interface. This variable can be bonded with SQL or PL\\SQL anonymous block. The scope of these variables is till the end of the session. These variables always preceded with a colon (:).")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"VARIABLE v_bind1 VARCHAR2(25); --Not PL/SQL statement\n\nDECLARE\nBEGIN\n    :v_bind1 := 'Binding 1';\n    DBMS_OUTPUT.PUT_LINE(:v_bind1);\nEND;\n--Not PL/SQL statements--\nVARIABLE v_bind2 VARCHAR2(25);\nVARIABLE v_bind3 VARCHAR2(25);\nEXECUTE :v_bind2 := 'Binding 2'; --SQL*Plus command\nEXECUTE :v_bind3 := 'Binding 3';\nPRINT :v_bind2;\nPRINT; --Displays all bind variable values in the session\n----\nSET AUTOPRINT ON --To turn on automatic printing of bind variable while assigning\n")),(0,i.kt)("h2",{id:"anchored-data-type-inheriting-data-type"},"Anchored Data type/ Inheriting data type"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It is used to pick up data type and size from a previously declared object into a new variable. Advantage of this is, when you change the data type or size of the field in the table, it will also affect this variable. So there is less maintenance.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"VNAME EMP.ENAME%TYPE;\nVEMP EMP%ROWTYPE; -- Record datatype variable\n")),(0,i.kt)("h2",{id:"execute-immediate"},"Execute Immediate"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Using Execute Immediate, we can parse and execute any SQL statement or a PL/SQL block dynamically in Oracle database"),(0,i.kt)("li",{parentName:"ul"},"Use of bind variable: Security against SQL injections and performance enhancement by reducing hard parsing."),(0,i.kt)("li",{parentName:"ul"},"Generally dynamic SQL is slower than static SQL so it should not be used unless absolutely necessary."),(0,i.kt)("li",{parentName:"ul"},"Main advantage of dynamic SQL is that it allows to perform DDL commands that are not supported directly within PL/SQL")),(0,i.kt)("h3",{id:"single-row-queries"},"Single Row Queries"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    l_sql VARCHAR2(100);\n    l_ename emp.ename%TYPE;\nBEGIN\n    l_sql:='SELECT ename FROM emp WHERE emp_no=1234';\n    EXECUTE IMMEDIATE l_sql INTO l_ename;\nEND;\n")),(0,i.kt)("h3",{id:"ddl-operations"},"DDL Operations"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"BEGIN\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE my_table';\nEND;\n")),(0,i.kt)("h3",{id:"plsql-block-using-execute-immediate"},"PL/SQL Block using EXECUTE IMMEDIATE"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    plsql_blk VARCHAR2(400);\nBEGIN\n    plsql_blk := 'DECLARE\n            var_user VARCHAR2(10);\n        BEGIN\n            SELECT user INTO var_user FROM DUAL;\n            DBMS_OUTPUT.PUT_LINE(''User:'' || var_user);\n        END;';\n    EXECUTE IMMEDIATE plsql_blk;\nEND;\n")),(0,i.kt)("h3",{id:"bind-variable"},"Bind Variable"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    l_sql VARCHAR2(100);\n    l_ename employees.first_name%TYPE;\nBEGIN\n    l_sql := 'SELECT first_name FROM employees WHERE employee_id = :empno and department_id = :deptno'; --:empno is a bind variable\n    EXECUTE IMMEDIATE l_sql INTO l_ename USING 100,90;--passing 100 into empno and 90 into deptno as bind variable\n    DBMS_OUTPUT.PUT_LINE(l_ename);\nEND;\n")),(0,i.kt)("h3",{id:"bulk-collect-into-with-execute-immediate"},"BULK COLLECT INTO with EXECUTE IMMEDIATE"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE nt_Fname IS TABLE OF VARCHAR2(60);\n    fname nt_Fname;\n    sql_qry VARCHAR2(150);\nBEGIN\n    sql_qry := 'SELECT first_name FROM employees';\n    EXECUTE IMMEDIATE sql_qry BULK COLLECT INTO fname;\nEND;\n")),(0,i.kt)("h2",{id:"utl_mail"},"UTL_MAIL"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"UTL_MAIL")," package was introduced in Oracle 10g to provide a simple API to allow email to be sent from PL/SQL.")),(0,i.kt)("h2",{id:"utl_file"},"UTL_FILE"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In Oracle PL/SQL, ",(0,i.kt)("inlineCode",{parentName:"li"},"UTL_FILE")," is an Oracle supplied package which is used for file operations (read and write) in conjunction with the underlying operating system.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    tc_logfile UTL_FILE.FILE_TYPE;\n    filedir VARCHAR2(10);\n    v_dir VARCHAR2(100);\n    read_line VARCHAR2(200);\nBEGIN\n    filedir := 'E:\\';\n    v_dir := 'CREATE OR REPLACE DIRECTORY TEMP_TEXT as '''|| filedir||'''';\n    EXECUTE IMMEDIATE v_dir;\n    tc_logfile := UTL_FILE.FOPEN('TEMP_TEXT','TestFile.txt','W'); --A to append; W to write; R to read\n    UTL_FILE.PUT_LINE(tc_logfile, 'STARTING..' || SYSTIMESTAMP);\n    UTL_FILE.PUT_LINE(tc_logfile, 'This is a test file');\n\n    IF UTL_FILE.IS_OPEN(tc_logfile) THEN\n        UTL_FILE.FCLOSE(tc_logfile);\n    END IF;\n    tc_logfile := UTL_FILE.FOPEN('TEMP_TEXT','TestFile.txt','R');\n\n    LOOP\n        BEGIN\n            UTL_FILE.GET_LINE(tc_logfile,read_line);\n            DBMS_OUTPUT.PUT_LINE(read_line);\n        EXCEPTION\n            WHEN NO_DATA_FOUND THEN\n            EXIT;\n        END;\n    END LOOP;\n\n    UTL_FILE.FCLOSE(tc_logfile);\nEND;\n")),(0,i.kt)("h2",{id:"external-tables"},"External tables"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE DIRECTORY directory_name AS 'C\\Users'; --Directory object\n\nCREATE TABLE students(name VARCHAR2(20),college VARCHAR2(20), major VARCHAR2(20))\nORGANIZATION EXTERNAL(\n    TYPE ORACLE_LOADER\n    --The ORACLE_LOADER access driver is the default. It can perform only data loads, and the data must come from text datafiles. Loads from external tables to internal tables are done by reading from the external tables' text-only datafiles.\n    --The ORACLE_DATAPUMP access driver can perform both loads and unloads. The data must come from binary dump files. Loads to internal tables from external tables are done by fetching from the binary dump files. Unloads from internal tables to external tables are done by populating the external tables' binary dump files.\n    DEFAULT DIRECTORY directory_name\n    ACCESS PARAMETERS (\n        RECORD DELIMITED BY NEWLINE\n        FIELDS TERMINATED BY ',' --comma separated\n        MISSING FIELD VALUE ARE NULL --if any data is missing, add them as NULL\n            ( name CHAR(20),\n            collage CHAR(20),\n            major CHAR(20)\n            )\n        )\n    LOCATION ('major.txt') --filename\n)\nREJECT LIMIT UNLIMITED; --stop the process if error comes more than specified value.\n")),(0,i.kt)("h2",{id:"import-data-from-excel-to-oracle-using-sql-developer"},"Import data from Excel to Oracle using SQL Developer"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Right click the table you want to insert data -> select import data -> select excel file -> click open")),(0,i.kt)("h2",{id:"xmlelement"},"XMLELEMENT"),(0,i.kt)("p",null,"The XMLELEMENT function is the basic unit for turning column data into XML fragments."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'SQL> SELECT XMLELEMENT("name", e.first_name) AS employee FROM HR.employees e\nWHERE e.employee_id = 160;\n--------------------------------------------------------------------------------\n<name>Louise</name>\n----\nSQL> SELECT XMLELEMENT("employee",\n        XMLELEMENT("employee_no", e.employee_id),\n        XMLELEMENT("name", e.first_name)\n        ) AS employee\n    FROM employees e\n    WHERE e.employee_id = 160;\n--------------------------------------------------------------------------------\n<employee><employee_no>160</employee_no><name>Louise</name></employee>\n----\nSQL> SELECT XMLELEMENT("employee",\n        XMLATTRIBUTES( --XMLATRIBUTES function converts column data into attributes of the parent element\n            e.employee_id AS "employee_id",\n            e.first_name AS "name")\n        ) AS employee\n    FROM employees e\n    WHERE e.employee_id = 160;\n--------------------------------------------------------------------------------\n<employee employee_id="160" name="Louise"></employee>\n----\nSQL> SELECT XMLELEMENT("employee",\n            XMLFOREST( --Like XMLATTRIBUTES, the XMLFOREST function allows you to process multiple columns at once.\n            e.employee_id AS "employee_id",\n            e.first_name AS "name")\n        ) AS employee\n    FROM employees e\n    WHERE e.employee_id = 160;\n--------------------------------------------------------------------------------\n<employee><employee_id>160</employee_id><name>Louise</name></employee>\n----\nSQL> SELECT XMLAGG( --XMLAGG function allows to aggregate separate fragments(multiple rows of data) into a single fragment\n        XMLELEMENT("emp",\n            XMLFOREST(\n            e.employee_id AS "empid",\n            e.first_name AS "name")\n        )\n    ) AS employees\n    FROM employees e\n    WHERE e.department_id = 50;\n-----------------------------------------------------------------\n<emp><empid>120</empid><name>Matthew</name></emp><emp><empid>121</empid><name>Adam</name></emp><emp><empid>122</empid><name>Payam</name></emp><emp><empid>123</empid><name>Shanta</name></emp><emp><empid>123</empid><name>Kevin</name></emp>\n')),(0,i.kt)("h2",{id:"sql-loader"},"SQL Loader"),(0,i.kt)("p",null,"SQL","*","Loader is a bulk loader utility used for moving data from external files into the Oracle database.\nSQL Loader Control File"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"LOAD DATA\nINFILE 'C:\\text_file.csv' --input file\nBADFILE 'C:\\textfile_bad.bad' --contains the records that are rejected by sql loader or oracle database becuase of invalid format. After a data is accepted by sql loader, it is sent to oracle database for insertion\nDISCARDFILE 'C:\\textfile_discard.dis' --records which are filtered out of the load because they don't meet the criteria specified in WHEN clause\nTRUNCATE INTO TABLE table_name --TRUNCATE to delete previous data in table\n--INSERT: Loads only if the target table is empty\n--APPEND: Loads rows if the target table is empty or not\n--REPLACE: First it delete the rows in the existing table and then loads the data\n--TRUNCATE: First it truncate the table and then loads the data\nWHEN OBJECT_TYPE <> 'INDEX' --i don't need any record with 'INDEX' in it\nFIELDS TERMINATED BY \",\" OPTIONALLY ENCLOSED BY \"#\" --delimited by , or #\nTRAILING NULL COLS --if the last column is empty, then treat this as NULL value; otherwise SQL Loader will treat this record as bad if the last column is empty\n(deptno, --column names in table\ndname,\njdate date'mm/dd/yyyy', --formating the date\nloc\"TRIM(:OBJECT_TYPE)\") --TRIM the white space if any\nor\n(deptno position(1:3), dname position(4:8), jdate position(9:18), loc position(19:22))\nor\n(deptno \"deptno+100\", --add 100 to the deptno\ndname \"upper(:dname)\", --upper case\njdate,\nloc \"decode(:loc,'Delhi','New Delhi',:loc)\")\nsqlldr control=C:\\textfile_control.ctl log=C:\\textfile_log.log --given the datafile in INFILE of control file\nor\nsqlldr datafile=C:\\text_file.csv control=C:\\textfile_control.ctl log=C:\\textfile_log.log\n")),(0,i.kt)("h2",{id:"local-screening"},"Local Screening"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If there are two variables with same name in the outer and inner block, and if we call the variable from inside the block, italways prefer the local (inner) variable. To refer to the outer variable, we need to use label.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"<<out_label>>\nDECLARE\n    x NUMBER := 100;\nBEGIN\n    FOR x IN 1..10 LOOP\n        DBMS_OUTPUT.PUT_LINE(out_label.x);\n    END LOOP;\nEND;\n")))}E.isMDXComponent=!0}}]);