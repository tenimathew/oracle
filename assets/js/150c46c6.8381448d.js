"use strict";(self.webpackChunkoracle=self.webpackChunkoracle||[]).push([[1648],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return N}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),s=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=s(e.components);return r.createElement(c.Provider,{value:n},e.children)},E={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=s(t),N=a,d=p["".concat(c,".").concat(N)]||p[N]||E[N]||l;return t?r.createElement(d,i(i({ref:n},u),{},{components:t})):r.createElement(d,i({ref:n},u))}));function N(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,i=new Array(l);i[0]=p;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var s=2;s<l;s++)i[s]=t[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},978:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return c},default:function(){return N},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return E}});var r=t(7462),a=t(3366),l=(t(7294),t(3905)),i=["components"],o={id:"Section 5. Stored Objects",sidebar_position:5,description:"Procedure, Function, Packages"},c=void 0,s={unversionedId:"plsql-tutorial/Section 5. Stored Objects",id:"plsql-tutorial/Section 5. Stored Objects",title:"Section 5. Stored Objects",description:"Procedure, Function, Packages",source:"@site/docs/plsql-tutorial/stored_objects.md",sourceDirName:"plsql-tutorial",slug:"/plsql-tutorial/Section 5. Stored Objects",permalink:"/oracle/plsql-tutorial/Section 5. Stored Objects",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{id:"Section 5. Stored Objects",sidebar_position:5,description:"Procedure, Function, Packages"},sidebar:"tutorialSidebar",previous:{title:"Section 4. Cursors",permalink:"/oracle/plsql-tutorial/Section 4. Cursors"},next:{title:"Tutorial - Extras",permalink:"/oracle/category/tutorial---extras"}},u={},E=[{value:"AUTHID",id:"authid",level:2},{value:"PL/SQL Bulk Collect",id:"plsql-bulk-collect",level:2},{value:"Bulk Collect with LIMIT clause",id:"bulk-collect-with-limit-clause",level:3},{value:"FORALL (Bulk Binding)",id:"forall-bulk-binding",level:2},{value:"Lower and Upper bound",id:"lower-and-upper-bound",level:3},{value:"Indices-of bound",id:"indices-of-bound",level:3},{value:"Values-of bound",id:"values-of-bound",level:3},{value:"SQL%BULK_ROWCOUNT",id:"sqlbulk_rowcount",level:3},{value:"SAVE EXCEPTIONS and SQL%BULK_EXCEPTION",id:"save-exceptions-and-sqlbulk_exception",level:3}],p={toc:E};function N(e){var n=e.components,t=(0,a.Z)(e,i);return(0,l.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"authid"},"AUTHID"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"AUTHID CURRENT_USER")," is used when you want a piece of code to execute with the privileges of the current user, and not with the privilege of the user who defined the PL/SQL code."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"AUTHID DEFINER")," is exactly opposite to ",(0,l.kt)("inlineCode",{parentName:"li"},"AUTHID CURRENT_USER"),". Using this clause is as same as granting public access to the PL/SQL code."),(0,l.kt)("li",{parentName:"ul"},"If no AUTHID clause is specified Oracle will default to ",(0,l.kt)("inlineCode",{parentName:"li"},"AUTHID DEFINER"),"."),(0,l.kt)("li",{parentName:"ul"},"It is suggestible to set ",(0,l.kt)("inlineCode",{parentName:"li"},"AUTHID")," clause. If not, an intruder may get access to privileges of the definer which an intruder should not get.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE OR REPLACE PROCEDURE create_dept(v_deptno NUMBER)\nAUTHID CURRENT_USER\nIS\nBEGIN\n    INSERT INTO departments VALUES (v_deptno);\nEND;\n")),(0,l.kt)("h2",{id:"plsql-bulk-collect"},"PL/SQL Bulk Collect"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Bulk collect is used to reduce the context switching between SQL engine and PL/SQL engine and to improve query performance."),(0,l.kt)("li",{parentName:"ul"},"Bulk collect will reduce the context switching by collecting all the SQL statement calls from PL/SQL program and sending them to SQL engine in just one go and vice versa."),(0,l.kt)("li",{parentName:"ul"},"Bulk collect clause can be used with ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT INTO"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"FETCH INTO"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"RETURNING INTO")," statements.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE rc_emp IS RECORD(\n    v_empno employees.employee_id%TYPE,\n    v_ename employees.first_name%TYPE,\n    v_sal employees.salary%TYPE);\n    TYPE cl_emp IS TABLE OF rc_emp;\n    v_emp cl_emp;\nBEGIN\n    SELECT employee_id, first_name, salary\n        BULK COLLECT INTO v_emp FROM employees;\n    FOR i IN 1..v_emp.COUNT LOOP\n        DBMS_OUTPUT.PUT_LINE(v_emp(i).v_empno || v_emp(i).v_ename || v_emp(i).v_sal);\n    END LOOP;\n\n    FORALL i IN 1..v_emp.COUNT\n        INSERT INTO temp_emp (employee_id,first_name,salary)\n            VALUES(v_emp(i).v_empno, v_emp(i).v_ename, v_emp(i).v_sal);\nEND;\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE nt_fName IS TABLE OF VARCHAR2(20);\n    fname nt_fName;\nBEGIN\n    SELECT first_name BULK COLLECT INTO fname FROM employees; --variable should be a collection\n    FOR i IN 1..fname.COUNT LOOP\n        DBMS_OUTPUT.PUT_LINE(i||fname(i));\n    END LOOP;\nEND;\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    CURSOR exp_cur IS\n    SELECT first_name FROM employees;\n    TYPE nt_fNAME IS TABLE OF VARCHAR2(20);\n    fname nt_fNAME;\nBEGIN\n    OPEN exp_cur;\n        FETCH exp_cur BULK COLLECT INTO fname;--Bulk collect does not need loop\n    FOR i IN fname.FIRST..fname.LAST LOOP\n        DBMS_OUTPUT.PUT_LINE(i||fname(i));\n    END LOOP;\n    CLOSE exp_cur;\nEND;\n")),(0,l.kt)("h3",{id:"bulk-collect-with-limit-clause"},"Bulk Collect with LIMIT clause"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Whenever we retrieve a large number of records using bulk collect, the program starts consuming lot of memory in order to be fast and efficient. That degrades the performance of the database."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"LIMIT")," clause will restrict the number of rows fetched."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"LIMIT")," clause can be only used with ",(0,l.kt)("inlineCode",{parentName:"li"},"FETCH INTO")," statement.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    CURSOR exp_cur IS\n        SELECT first_name FROM employees;\n    TYPE nt_fNAME IS TABLE OF VARCHAR2(20);\n    fname nt_fNAME;\nBEGIN\n    OPEN exp_cur;\n    LOOP\n        FETCH exp_cur BULK COLLECT INTO fname LIMIT 10;\n        FOR i IN 1..fname.COUNT LOOP\n            DBMS_OUTPUT.PUT_LINE(i||fname(i));\n        END LOOP;\n        EXIT WHEN fname.COUNT = 0;\n    END LOOP;\n    CLOSE exp_cur;\nEND;\n")),(0,l.kt)("h2",{id:"forall-bulk-binding"},"FORALL (Bulk Binding)"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"FORALL")," statement reduces context switches which occur during the execution of a DML statement by sending it in batches instead of one at a time."),(0,l.kt)("li",{parentName:"ul"},"With ",(0,l.kt)("inlineCode",{parentName:"li"},"BULK COLLECT")," we were fetching data from table and storing it into the collection. But in ",(0,l.kt)("inlineCode",{parentName:"li"},"FORALL")," statement, we will fetch the data from the collection and store it into the table."),(0,l.kt)("li",{parentName:"ul"},"A ",(0,l.kt)("inlineCode",{parentName:"li"},"FORALL")," statement can have only one DML statement at a time.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"FORALL i IN bound_clause --Bound clause decides the number of iteration.\n[SAVE EXCEPTIONS] --It helps the DML statements to keep running even when there is an exception. --Using this is recommended\n--DML statement;\n")),(0,l.kt)("h3",{id:"lower-and-upper-bound"},"Lower and Upper bound"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The collection should have consecutive index numbers."),(0,l.kt)("li",{parentName:"ul"},"If an element in the range is missing or was deleted, PL/SQL raises an exception.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE myArray IS TABLE OF NUMBER(2);\n    col_var myArray := myArray(9,45,1,24,5,4,7,54,6,23);\nBEGIN\n    FORALL i IN 1..col_var.COUNT\n        INSERT INTO tbl_mulpxn VALUES (col_var(i));\n    DBMS_OUTPUT.PUT_LINE(SQL %ROWCOUNT);\nEND;\n")),(0,l.kt)("h3",{id:"indices-of-bound"},"Indices-of bound"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The indexes need not be consecutive."),(0,l.kt)("li",{parentName:"ul"},"If a subscript in the range does not exist in the collection, that subscript is skipped."),(0,l.kt)("li",{parentName:"ul"},"If collection is an associative array, it must be indexed by ",(0,l.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER"),".")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE myArray IS TABLE OF NUMBER(2);\n    col_var myArray := myArray(9,45,1,24,5,4,7,54,6,23);\nBEGIN\n    col_var.DELETE(3 , 6);\n    FORALL i IN INDICES OF col_var\n        INSERT INTO tbl_mulpxn VALUES (col_var(i));\n    DBMS_OUTPUT.PUT_LINE(SQL %ROWCOUNT);\nEND;\n----\nDECLARE\n    TYPE myArray IS TABLE OF NUMBER(2);\n    col_var myArray := myArray(9,45,1,24,5,4,7,54,6,23);\nBEGIN\n    col_var.DELETE(3 , 6);\n    FORALL i IN INDICES OF col_var BETWEEN 1 AND 10\n        INSERT INTO tbl_mulpxn VALUES (col_var(i));\n    DBMS_OUTPUT.PUT_LINE(SQL %ROWCOUNT);\nEND;\n")),(0,l.kt)("h3",{id:"values-of-bound"},"Values-of bound"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It requires two collection; source collection and indexing collection"),(0,l.kt)("li",{parentName:"ul"},"The subscripts for the ",(0,l.kt)("inlineCode",{parentName:"li"},"FORALL")," indexing collection are taken from the values of the elements in source collection"),(0,l.kt)("li",{parentName:"ul"},"The indexing collection must be a nested table, or an associative array"),(0,l.kt)("li",{parentName:"ul"},"The elements of the indexing collection must be of either ",(0,l.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"BINARY_INTEGER")),(0,l.kt)("li",{parentName:"ul"},"If it is associate array, then it must be indexed by ",(0,l.kt)("inlineCode",{parentName:"li"},"PLS_INTEGER")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"BINARY_INTEGER")),(0,l.kt)("li",{parentName:"ul"},"Indexing collection is a group of indexes that the ",(0,l.kt)("inlineCode",{parentName:"li"},"FORALL")," statement can loop through")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"DECLARE\n    TYPE myArray IS TABLE OF NUMBER(2);--Source collection\n    src_col myArray := myArray(9,45,1,24,5,4,7,54,6,23);\n    TYPE yourArray IS TABLE OF PLS_INTEGER;--Indexing collection\n    idx_col yourArray:=yourArray();\nBEGIN\n    idx_col.EXTEND(2);\n    idx_col(1):=4; --24 inserted here; src_col(4)\n    idx_col(2):=8; --54 inserted here; src_col(8)\n    FORALL i IN VALUES OF idx_col --idx_col(1) = 4; i =4\n        INSERT INTO tbl_mulpxn VALUES (src_col(i)); --src_col(4) = 24\n    DBMS_OUTPUT.PUT_LINE(SQL %ROWCOUNT);\nEND;\n")),(0,l.kt)("h3",{id:"sqlbulk_rowcount"},"SQL%BULK_ROWCOUNT"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"SQL%BULK_ROWCOUNT")," cursor attribute gives granular information about the rows affected by each iteration of the FORALL statement."),(0,l.kt)("li",{parentName:"ul"},"Every row in the driving collection has a corresponding row in the ",(0,l.kt)("inlineCode",{parentName:"li"},"SQL%BULK_ROWCOUNT")," cursor attribute."),(0,l.kt)("li",{parentName:"ul"},'In the below code, we can see that rows affected for the username "BANANA" is zero.')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE bulk_rowcount_test AS\n    SELECT *\n    FROM all_users;\n----\nDECLARE\n    TYPE t_array_tab IS TABLE OF VARCHAR2(30);\n    l_array t_array_tab := t_array_tab('SCOTT', 'SYS','SYSTEM', 'DBSNMP', 'BANANA');\nBEGIN\n    --Perform bulk delete operation.\n    FORALL i IN l_array.FIRST .. l_array.LAST\n        DELETE FROM bulk_rowcount_test\n            WHERE username = l_array(i);\n    --Report affected rows.\n    FOR i IN l_array.FIRST .. l_array.LAST LOOP\n        DBMS_OUTPUT.PUT_LINE('Element: ' || RPAD(l_array(i), 15, ' ') ||\n        ' Rows affected: ' || SQL %BULK_ROWCOUNT(i));\n    END LOOP;\nEND;\n/\nElement: SCOTT Rows affected: 1\nElement: SYS Rows affected: 1\nElement: SYSTEM Rows affected: 1\nElement: DBSNMP Rows affected: 1\nElement: BANANA Rows affected: 0\n")),(0,l.kt)("h3",{id:"save-exceptions-and-sqlbulk_exception"},"SAVE EXCEPTIONS and SQL%BULK_EXCEPTION"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The following code creates a collection with 100 rows, but sets the value of rows 50 and 51 to NULL."),(0,l.kt)("li",{parentName:"ul"},'Since the "exception_test" table does not allow nulls, these rows will result in an exception.'),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"SAVE EXCEPTIONS")," clause allows the bulk operation to continue past any exceptions, but if any exceptions were raised , it will jump to the exception handler once all the operations are complete."),(0,l.kt)("li",{parentName:"ul"},"In this case, the exception handler just loops through the ",(0,l.kt)("inlineCode",{parentName:"li"},"SQL%BULK_EXCEPTION")," cursor attribute to see what errors occurred.")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE exception_test (\n    id NUMBER(10) NOT NULL);\n----\nDECLARE\n    TYPE t_tab IS TABLE OF exception_test%ROWTYPE;\n    l_tab t_tab := t_tab();\n    l_error_count NUMBER(10);\n    ex_dml_errors EXCEPTION;\n    PRAGMA EXCEPTION_INIT(ex_dml_errors, -24381);\nBEGIN\n    --Fill the collection.\n    FOR i IN 1..100 LOOP\n        l_tab.EXTEND;\n        l_tab(i).id := i;\n    END LOOP;\n\n    --Cause a failure.\n    l_tab(50).id := NULL;\n    l_tab(51).id := NULL;\n    EXECUTE IMMEDIATE 'TRUNCATE TABLE exception_test';\n\n    --Perform a bulk operation.\n    BEGIN\n        FORALL i IN l_tab.FIRST..l_tab.LAST SAVE EXCEPTIONS\n            INSERT INTO exception_test\n                VALUES l_tab(i);\n    EXCEPTION\n        WHEN ex_dml_errors THEN\n            l_error_count := SQL%BULK_EXCEPTIONS.COUNT;\n            DBMS_OUTPUT.PUT_LINE('Number of failures: ' || l_error_count);\n            FOR i IN 1 .. l_error_count LOOP\n                DBMS_OUTPUT.PUT_LINE('Error: ' || i ||\n                ' Array Index: ' || SQL%BULK_EXCEPTIONS(i).ERROR_INDEX ||\n                ' Error Code: ' || SQL%BULK_EXCEPTIONS(i).ERROR_CODE ||\n                ' Message1: ' || SQLERRM(SQL%BULK_EXCEPTIONS(i).ERROR_CODE) ||\n                ' Message2: ' || SQLERRM(-SQL%BULK_EXCEPTIONS(i).ERROR_CODE)) ;\n            END LOOP;\n    END;\nEND;\n/\nNumber of failures: 2\nError: 1 Array Index: 50 Error Code: 1400 Message1: -1400: non-ORACLE exception Message2: ORA-01400: cannot insert NULL into ()\nError: 2 Array Index: 51 Error Code: 1400 Message1: -1400: non-ORACLE exception Message2: ORA-01400: cannot insert NULL into ()\n")))}N.isMDXComponent=!0}}]);